---
siderbar_position: 1
---

# 2.0 Network

## 2주차

- HTTP

  - [HTTP 프로토콜에 대해서 설명해주세요.](#http-프로토콜에-대해서-설명해주세요)
  - [HTTP의 요청/응답 모델에 대해 설명해주세요.](#http의-요청응답-모델에-대해-설명해주세요)
  - [HTTP 메서드중 GET과 POST의 차이점에 대해 설명해주세요.](#http-메서드중-get과-post의-차이점에-대해-설명해주세요)
  - [HTTP 메서드중 PUT과 PATCH의 차이점에 대해 설명해주세요.](#http-메서드중-put과-patch의-차이점에-대해-설명해주세요)
  - [HTTP 상태 코드가 뭔가요? 알고 있는 상태 코드 몇가지 설명해주세요..](#http-상태-코드가-뭔가요-알고-있는-상태-코드-몇가지-설명해주세요)
  - [HTTP 헤더가 뭘까요? 알고 있는 헤더 몇 가지 설명해주세요.](#http-헤더가-뭘까요-알고-있는-헤더-몇-가지-설명해주세요)
  - [HTTP의 무상태성(Stateless)에 대해서 설명해주세요.](#http의-무상태성stateless에-대해서-설명해주세요)
  - [HTTP Keep-Alive에 대해서 설명해주세요.](#http-keep-alive에-대해서-설명해주세요)
  - [HTTP 파이프라이닝에 대해서 설명해주세요.](#http-파이프라이닝에-대해서-설명해주세요)
  - [HTTP/1.1, HTTP/2, HTTP/3 각각의 특징에 대해 설명해주세요. ](#http11-http2-http3-각각의-특징에-대해-설명해주세요)

  - HTTPS
  - [HTTPS에 대해서 설명해주세요.](#https에-대해서-설명해주세요)
  - [SSL/TLS이 뭔가요?](#ssltls이-뭔가요)
  - [대칭키 암호화 방식에 대해 설명해주세요.](#대칭키-암호화-방식에-대해-설명해주세요)
  - [비대칭키(공개키) 암호화 방식에 대해서 설명해주세요.](#비대칭키공개키-암호화-방식에-대해서-설명해주세요)
  - [전자 서명에 대해서 설명해주세요.](#전자-서명에-대해서-설명해주세요)
  - [HTTPS 암호화 과정에 대해 설명해주세요. (SSL Handshake의 동작 과정을 설명해 주세요.)](#https-암호화-과정에-대해-설명해주세요-ssl-handshake의-동작-과정을-설명해-주세요)

- DNS
- [DNS가 뭔가요?](#dns가-뭔가요)
- [DNS 작동 방식에 대해 설명해주세요.](#dns-작동-방식에-대해-설명해주세요)
- [DNS 질의 종류에 대해 설명해주세요.](#dns-질의-종류에-대해-설명해주세요)
- [DNS 서버에게 IP 주소를 요청할 때, 왜 UDP를 사용하나요?](#dns-서버에게-ip-주소를-요청할-때-왜-udp를-사용하나요)
- [DNS 레코드가 무엇인가요?](#dns-레코드가-무엇인가요)

---

# HTTP

## HTTP 프로토콜에 대해서 설명해주세요.

> HTTP(Hypertext Transfer Protocol)는 웹에서 데이터를 주고받는 서버-클라이언트 모델의 프로토콜, 웹 브라우저가 서버와 통신하는 규칙이다.

사용자가 웹사이트를 방문하면 브라우저가 웹서버로 리소스를 요청한다.  
요청을 받은 웹서버는 HTML, CSS와 같은 리소스를 응답으로 돌려준다.  
클라이언트의 요청과 서버의 응답 사이에는 여러 프록시 서버가 있다.  
프록시 서버는 캐시를 보관하거나 보안을 위해 서버의 IP 주소를 숨기는 등 다양한 역할을 한다.  
이 모든 통신은 안전하기 이뤄지기 위해 기본적으로 TCP(Transmission Control Protocol) 연결을 사용한다.

## HTTP의 요청/응답 모델에 대해 설명해주세요.

> HTTP는 클라이언트가 서버에 요청을 보내고, 서버가 그 요청에 대한 응답을 보내는 요청/응답(Request/Response) 모델로 작동한다.

클라이언트는 요청 라인, 헤더, 바디 등을 포함한 HTTP 요청을 서버로 보내며,  
서버는 상태 코드, 헤더, 바디 등을 포함한 HTTP 응답을 클라이언트에 반환한다.

## HTTP 메서드중 GET과 POST의 차이점에 대해 설명해주세요.

### GET

> 서버로부터 정보를 요청할 때 사용되는 HTTP 메서드이다.

1. 요청할 때 필요한 데이터를 Body에 담지 않고, 쿼리 스트링을 통해 전송한다.  
   예: www.example.com/resources?name1=value1&name2=value2
   파라미터에 내용이 노출되기 때문에 민감한 데이터를 다룰 때 GET 요청을 사용하지 않는다.
2. 데이터가 담기는 곳: HTTP 패킷 Header
3. GET 요청은 브라우저 히스토리에 남는다.
4. GET 요청은 길이 제한이 있다.
5. 불필요한 요청을 제한하기 위해 요청이 캐시될 수 있다.

- js, css, 이미지 같은 정적 컨텐츠는 데이터 양이 크고, 변경될 일이 적어서 반복해서 요청을 보낼 필요가 없다.  
  그래서 프론트엔드 개발을 하다보면 정적 컨텐츠가 캐시되어 컨텐츠를 변경해도 내용이 바뀌지 않는 경우가 종종 발생한다.  
  이 때는 브라우저의 캐시를 지워주면 서버에 요청을 보내게 된다.

### POST

> 정보를 생성/업데이트하기 위해 서버에 데이터를 보내는 HTTP 메서드이다.

1. GET과 달리 전송할 데이터를 HTTP 메세지의 Body에 담아서 전송한다.

- Body의 타입은 요청 헤더의 Content-Type에서 설정해주어야 한다.  
  타입을 선언하지 않으면 서버는 내용이나 url에 포함된 리소스의 확장자명으로 데이터 타입을 유추한다.  
  알 수 없는 경우에는 application/octet-stream으로 요청을 처리한다.

- 데이터가 Body로 전송되고 내용이 눈에 보이지 않아서 GET 요청보다 보안적인 면에서 더 안전하다고 생각할 수 있겠지만, 크롬 개발자 도구 등으로 확인할 수 있기 때문에 민감한 정보는 반드시 암호화가 필요하다.

2. 데이터가 담기는 곳: HTTP 패킷 Body
3. POST 요청은 캐시되지 않는다.
4. POST 요청은 브라우저 히스토리에 남지 않는다.
5. POST 요청은 데이터 길이에 제한이 없다.

#### GET과 POST의 차이점

- **사용목적**: GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트 할 때 사용된다.

- **DB로 비유**: GET은 SELECT에 가깝고, POST는 CREATE에 가깝다.

- **요청에 body 유무**: GET은 URL 파라미터에 데이터를 담아 보내기 때문에 HTTP 메세지에 body가 없다. POST는 body에 데이터를 담아보낸다.

- **멱등성(idempotent)**: GET 요청은 멱등이고 POST는 멱등이 아니다.

<small>멱등이란?</small>

```markdown
멱등의 사전적 의미는 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 뜻한다.
GET은 리소스를 조회한다는 점에서 여러 번 요청하더라도 응답이 똑같을 것이다.
반대로 POST는 리소스를 생성하거나 업데이트할 때 사용되기 때문에 멱등이 아니라고 볼 수 있다.
(POST로 서버 리소스가 변경될 수 있다.)
```

## HTTP 메서드중 PUT과 PATCH의 차이점에 대해 설명해주세요.

### PUT

> 리소스를 **완전히 대체**하거나 새로 생성하기 위해 사용되는 HTTP 메서드이다.

1. **전체 리소스를 업데이트:** PUT 요청은 지정된 리소스의 전체를 새 데이터로 대체한다. 리소스가 존재하지 않으면, 새로운 리소스를 생성한다.

   - 예를 들어, 클라이언트가 `/users/123`에 대해 PUT 요청을 보낼 때, 서버는 ID가 123인 사용자의 모든 데이터를 요청된 데이터로 완전히 대체한다. 기존 필드가 누락되면 그 필드는 기본값으로 설정되거나 삭제될 수 있다.

2. **데이터가 담기는 곳:** HTTP 패킷 Body
3. **PUT 요청은 멱등성(idempotent)을 가진다.**

   - 멱등성: PUT 요청을 여러 번 보내더라도 결과가 동일하다. 동일한 리소스에 같은 내용의 PUT 요청을 여러 번 보내더라도, 리소스는 한 번만 수정된다.

4. **사용 목적:** 특정 리소스를 전체적으로 수정하거나 새로 생성할 때 사용된다.

### PATCH

> 리소스의 **일부를 수정**하기 위해 사용되는 HTTP 메서드이다.

1. **부분 업데이트:** PATCH 요청은 리소스의 일부만을 수정한다. 전체 리소스를 대체하지 않고, 특정 필드나 속성만 변경할 수 있다.

   - 예를 들어, 클라이언트가 `/users/123`에 대해 PATCH 요청을 보낼 때, 서버는 ID가 123인 사용자의 일부 필드만 업데이트한다. 나머지 필드는 변경되지 않는다.

2. **데이터가 담기는 곳:** HTTP 패킷 Body
3. **PATCH 요청은 멱등성(idempotent)을 가질 수도 있고, 아닐 수도 있다.**

   - 멱등성: PATCH 요청이 멱등성을 가지려면, 같은 내용을 여러 번 보내도 결과가 동일해야 한다.  
     그러나, 일부 구현에서는 동일한 PATCH 요청을 여러 번 보냈을 때 결과가 달라질 수 있다.

4. **사용 목적:** 특정 리소스의 일부 속성만 수정할 때 사용된다.

#### PUT과 PATCH의 차이점

- **사용 목적:** PUT은 리소스 전체를 대체하거나 새로 생성할 때 사용되고, PATCH는 리소스의 일부를 수정할 때 사용된다.

- **리소스 처리:** PUT은 전체 리소스를 처리하며, 누락된 필드가 있으면 삭제될 수 있다.
  PATCH는 필요한 부분만 수정하며, 나머지 필드에는 영향을 주지 않는다.

- **멱등성:** PUT은 멱등성을 가지며, PATCH는 멱등성을 가질 수도 있고, 아닐 수도 있다.

- **데이터 전달:** 둘 다 HTTP 패킷의 Body에 데이터를 담아 보내지만, PUT은 리소스 전체를 전달하고, PATCH는 변경된 부분만 전달한다.

- **DB로 비유:** PUT은 특정 데이터의 전체 레코드를 대체하는 `UPDATE`와 유사하고, PATCH는 특정 필드만 수정하는 `PARTIAL UPDATE`와 유사하다.

## HTTP 상태 코드가 뭔가요? 알고 있는 상태 코드 몇가지 설명해주세요..

> HTTP 상태 코드는 서버가 클라이언트의 요청을 처리한 결과를 나타내는 3자리 숫자이다.

```markdown
200은 요청이 성공적으로 처리되었음을 의미한다.
404는 요청한 리소스를 찾을 수 없음을 의미한다.
500은 서버에 내부 오류가 발생했음을 나타낸다.
```

## HTTP 헤더가 뭘까요? 알고 있는 헤더 몇 가지 설명해주세요.

> HTTP 헤더는 요청이나 응답에 대한 메타데이터를 전달하는 데 사용된다.

```markdown
Content-Type은 전송되는 데이터의 형식을 지정한다.
Authorization은 클라이언트의 인증 정보를 전달한다.
User-Agent는 클라이언트의 애플리케이션 정보를 서버에 전달한다.
```

## HTTP의 무상태성(Stateless)에 대해서 설명해주세요.

> HTTP는 무상태 프로토콜로, 각 요청이 독립적으로 처리되며, 서버는 이전 요청에 대한 정보를 저장하지 않는다.  
>  즉, 클라이언트의 상태를 서버가 기억하지 않기 때문에, 클라이언트는 각 요청 시 필요한 모든 정보를 함께 전송해야한다.

## HTTP Keep-Alive에 대해서 설명해주세요.

> HTTP Keep-Alive는 하나의 TCP 연결을 통해 여러 HTTP 요청/응답을 주고받을 수 있도록 하는 기능이다.  
> 이를 통해 연결을 재설정하는 오버헤드를 줄이고, 통신의 효율성을 높일 수 있다.

## HTTP 파이프라이닝에 대해서 설명해주세요.

> HTTP 파이프라이닝은 하나의 연결에서 다수의 요청을 동시에 보내는 기능으로, 요청들이 순차적으로 처리되길 기다리지 않고 동시에 전송될 수 있다.

## HTTP/1.1, HTTP/2, HTTP/3 각각의 특징에 대해 설명해주세요.

### HTTP/1.1

> 기본적인 요청/응답 모델과 Keep-Alive, 파이프라이닝 등을 지원한다.

### HTTP/2

> 멀티플렉싱, 헤더 압축, 서버 푸시 등으로 성능을 개선하며, 더 빠르고 효율적인 데이터 전송을 지원한다.

### HTTP/3

> UDP 기반의 QUIC 프로토콜을 사용해, 연결 수립 시간을 단축하고, 패킷 손실에 대한 복원력이 뛰어나며, 지연 시간이 적은 데이터 전송을 가능하게 한다.

# HTTPS

## HTTPS에 대해서 설명해주세요.

> HTTPS(HyperText Transfer Protocol Secure)는 HTTP에 SSL/TLS 암호화 프로토콜을 추가하여 보안을 강화한 프로토콜이다.

HTTPS는 데이터 전송 중에 발생할 수 있는 도청, 스니핑, 중간자 공격 등을 방지하며, 웹사이트의 신뢰성을 높이기 위해 사용된다.

## SSL/TLS이 뭔가요?

### SSL/TLS가 뭔가요?

> SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 인터넷 통신에서 데이터의 기밀성, 무결성, 그리고 인증을 보장하기 위한 암호화 프로토콜이다.  
> 두 프로토콜은 네트워크 상에서 데이터를 안전하게 전송하기 위해 설계되었으며, 주로 웹 브라우저와 웹 서버 간의 통신을 보호하는 데 사용된다.

### SSL(Secure Sockets Layer)

- SSL은 1990년대 초반에 넷스케이프(Netscape)에서 개발한 최초의 암호화 프로토콜로, 웹 브라우저와 서버 간의 보안 통신을 가능하게 했다. SSL은 데이터를 암호화하여 전송하는 방식으로, 네트워크를 통해 전송되는 정보가 제3자에게 노출되거나 조작되지 않도록 보호한다.
- **SSL의 주요 목표:**
  - **기밀성(Confidentiality):** 데이터가 암호화되어 전송되므로, 전송 중에 누군가가 데이터를 가로채더라도 내용을 이해할 수 없다.
  - **무결성(Integrity):** 데이터가 전송 중에 변경되지 않았음을 보장한다. 즉, 데이터가 중간에서 조작되었는지 여부를 확인할 수 있다.
  - **인증(Authentication):** 클라이언트와 서버가 서로의 신원을 확인할 수 있도록 한다. 이는 중간자 공격(man-in-the-middle attack)을 방지하는 데 중요한 역할을 한다.

### TLS(Transport Layer Security)

- TLS는 SSL의 후속 프로토콜로, 보안성과 성능을 개선한 버전이다. SSL 3.0 이후의 버전은 TLS 1.0으로 발전하였으며, 현재는 TLS 1.3까지 개발되었다. TLS는 SSL의 취약점을 보완하고 더 강력한 암호화 알고리즘을 도입하여, 보안성을 한층 높였다.
- **TLS의 주요 특징:**
  - **더 강력한 암호화:** TLS는 더 안전한 암호화 알고리즘을 사용하여 데이터의 기밀성을 강화했다.
  - **향상된 인증:** TLS는 인증서와 공인된 인증 기관(CA, Certificate Authority)을 사용하여 서버와 클라이언트의 신원을 더 신뢰성 있게 검증한다.
  - **세션 키:** TLS는 클라이언트와 서버 간에 세션 키를 생성하여, 해당 세션 동안의 모든 통신을 암호화한다. 이 세션 키는 대칭키 방식으로 사용되며, 세션 종료 시 폐기된다.

### SSL/TLS 핸드셰이크 과정

- SSL/TLS 프로토콜이 안전한 연결을 수립하기 위해서는 클라이언트와 서버 간의 초기 핸드셰이크 과정이 필요하다. 이 과정에서는 암호화 알고리즘을 협상하고, 서버의 인증서를 검증하며, 세션 키를 생성하는 절차가 포함된다. 핸드셰이크가 성공적으로 완료되면, 이후의 통신은 암호화된 채널을 통해 안전하게 이루어진다.

### SSL/TLS의 중요성:

- 오늘날 SSL/TLS는 HTTPS 프로토콜의 핵심 요소로, 웹사이트와 사용자 간의 보안 통신을 보장하는 데 필수적이다. 이를 통해 사용자는 민감한 정보를 안전하게 전송할 수 있으며, 웹사이트는 사용자에게 신뢰성을 제공한다.

결론적으로, SSL과 TLS는 인터넷 상에서 데이터를 안전하게 전송하기 위한 필수적인 보안 프로토콜이며, 웹 애플리케이션, 이메일, VPN 등 다양한 영역에서 널리 사용되고 있다.

## 대칭키 암호화 방식에 대해 설명해주세요.

> 대칭키 암호화 방식은 데이터를 암호화하고 복호화하는 데 **하나의 동일한 키**를 사용하는 암호화 방식이다.
> 이 방식에서는 암호화와 복호화에 사용되는 키가 같기 때문에, 키를 공유하는 모든 당사자는 데이터를 암호화하거나 복호화할 수 있다.

1. **작동 방식:**

   - 대칭키 암호화에서 데이터를 암호화할 때, 평문(Plaintext)에 암호화 알고리즘을 적용하여 암호문(Ciphertext)을 생성한다. 이 암호문은 대칭키를 가지고 있는 사람만이 복호화할 수 있다. 복호화할 때는 암호화에 사용된 것과 동일한 키를 사용하여 암호문을 원래의 평문으로 되돌린다.

2. **장점:**

   - **속도가 빠르다:** 대칭키 암호화는 비대칭키 암호화에 비해 연산이 간단하고 빠르다. 따라서 대량의 데이터를 처리하는 데 적합하다.
   - **간단한 구조:** 대칭키 암호화 알고리즘은 상대적으로 간단하여 구현이 용이하다.

3. **단점:**

   - **키 분배의 어려움:** 대칭키를 안전하게 공유하는 것이 어려운 점이다. 키가 노출되면 통신의 보안이 깨질 수 있기 때문에, 키를 안전하게 전달하고 관리하는 것이 매우 중요하다.
   - **확장성 문제:** 각 통신 쌍마다 서로 다른 대칭키를 사용해야 하므로, 많은 사용자나 시스템 간의 통신에서는 키 관리가 복잡해진다.

4. **대표적인 알고리즘:**
   - **AES(Advanced Encryption Standard):** 현재 가장 널리 사용되는 대칭키 암호화 알고리즘으로, 보안성과 성능이 뛰어나다.
   - **DES(Data Encryption Standard):** 한때 널리 사용되었으나, 현재는 보안이 취약하여 더 이상 사용되지 않는다.
   - **3DES(Triple DES):** DES의 보안성을 강화하기 위해 동일한 데이터를 세 번 암호화하는 방식으로, 한때 많이 사용되었으나 현재는 AES로 대체되고 있다.

## 비대칭키(공개키) 암호화 방식에 대해서 설명해주세요.

> 비대칭키 암호화 방식은 두 개의 서로 다른 키, 즉 공개키와 개인키를 사용하는 암호화 방식이다.
> 이 방식은 암호화와 복호화에 서로 다른 키를 사용하기 때문에 "비대칭"이라고 불린다.
> 공개키는 누구나 알 수 있도록 공개되며, 개인키는 비밀로 유지된다.

1. **작동 원리:**

   - 공개키로 데이터를 암호화하면, 해당 데이터를 복호화할 수 있는 유일한 방법은 대응하는 개인키를 사용하는 것이다. 반대로, 개인키로 암호화된 데이터는 대응하는 공개키로만 복호화할 수 있다.
   - 예를 들어, A가 B에게 메시지를 보낼 때, B의 공개키로 메시지를 암호화하여 전송하면, B만이 자신의 개인키를 사용하여 메시지를 복호화할 수 있다.

2. **장점:**

   - **키 배포의 용이성:** 비대칭키 암호화에서는 공개키를 안전하게 배포하는 것이 용이하다. 개인키를 노출시키지 않고도 안전한 통신을 할 수 있다.
   - **보안성:** 개인키는 공개되지 않으므로, 수신자만이 암호화된 데이터를 복호화할 수 있다. 이는 데이터의 기밀성과 보안성을 크게 높인다.
   - **전자 서명:** 비대칭키 암호화는 전자 서명에 사용되기도 한다. 개인키로 서명된 데이터는 해당 공개키로 서명을 검증할 수 있어, 데이터의 무결성과 서명자의 신원을 확인할 수 있다.

3. **단점:**

   - **속도:** 비대칭키 암호화는 대칭키 암호화에 비해 처리 속도가 느리다. 복잡한 수학적 연산을 사용하기 때문에, 대량의 데이터를 처리하기에는 비효율적일 수 있다.
   - **복잡성:** 알고리즘이 복잡하고 구현이 어려워, 대칭키 암호화에 비해 시스템 리소스를 더 많이 소모한다.

4. **대표적인 알고리즘:**
   - **RSA:** 가장 널리 사용되는 비대칭키 암호화 알고리즘 중 하나로, 높은 보안성을 제공한다. 일반적으로 공개키 암호화와 전자 서명에 사용된다.
   - **ECC(Elliptic Curve Cryptography):** 보다 효율적인 비대칭키 암호화 알고리즘으로, 짧은 키 길이로도 높은 수준의 보안을 제공한다.
   - **DSA(Digital Signature Algorithm):** 주로 전자 서명에 사용되는 알고리즘으로, 디지털 서명 및 검증 과정에서 사용된다.

### 대칭키와 비대칭키의 조합

실제 많은 보안 시스템에서는 대칭키와 비대칭키 암호화를 결합하여 사용한다. 예를 들어, TLS(Transport Layer Security)에서는 비대칭키 암호화를 사용해 대칭키를 안전하게 교환한 후, 이 대칭키로 데이터 통신을 암호화하는 방식이다. 이를 통해 두 방식의 장점을 결합하여, 보안성과 효율성을 모두 확보할 수 있다.

## 전자 서명에 대해서 설명해주세요.

> 전자 서명은 디지털 문서나 메시지의 신뢰성을 보장하고, 작성자의 신원을 확인하며, 데이터의 무결성을 검증하기 위한 중요한 기술이다. 컴퓨터 네트워크 관점에서 전자 서명은 데이터 전송 중 발생할 수 있는 위조, 변조, 스푸핑(spoofing) 등의 공격을 방지하는 데 핵심적인 역할을 한다.

1. **전자 서명의 기본 원리:**

   - 전자 서명은 일반적으로 **비대칭키 암호화 방식**을 기반으로 한다. 전자 서명을 생성하기 위해, 서명자는 자신의 **개인키**를 사용하여 특정 데이터(예: 문서, 메시지, 파일)의 해시값을 암호화한다. 이 암호화된 해시값이 바로 전자 서명이다.
   - 수신자는 서명자의 **공개키**를 사용하여 서명을 복호화하고, 원본 데이터의 해시값과 비교하여 데이터가 변경되지 않았음을 확인할 수 있다.

2. **컴퓨터 네트워크에서의 전자 서명 활용:**

   - **데이터 무결성 보장:** 네트워크를 통해 전송되는 데이터는 중간에서 공격자에 의해 변조될 위험이 있다. 전자 서명을 사용하면, 수신자가 데이터를 수신할 때 서명을 검증하여 데이터가 전송 중에 변경되지 않았는지 확인할 수 있다.
   - **신원 인증:** 전자 서명은 서명자가 누구인지 확인할 수 있도록 한다. 네트워크 상에서 데이터나 메시지를 전송할 때, 수신자는 서명을 통해 송신자의 신원을 검증할 수 있다. 이는 피싱 공격이나 중간자 공격을 방지하는 데 효과적이다.
   - **부인 방지:** 전자 서명을 사용하면, 서명자가 서명한 데이터를 나중에 부인할 수 없다. 이로 인해, 법적 효력을 가지는 디지털 계약서나 중요한 문서에 신뢰성을 부여할 수 있다.

3. **전자 서명의 생성 및 검증 과정:**

   - **서명 생성:**
     1. 송신자가 전송할 데이터를 해시 함수(예: SHA-256)를 사용하여 해시값(고정 길이의 데이터 요약본)을 생성한다.
     2. 이 해시값을 송신자의 개인키로 암호화하여 전자 서명을 생성한다.
     3. 생성된 전자 서명은 원본 데이터와 함께 수신자에게 전송된다.
   - **서명 검증:**
     1. 수신자는 송신자의 공개키를 사용하여 전자 서명을 복호화하고, 해시값을 복원한다.
     2. 수신자는 원본 데이터에 동일한 해시 함수를 적용하여 해시값을 생성하고, 복원된 해시값과 비교한다.
     3. 두 해시값이 일치하면, 데이터가 변조되지 않았음을 확인할 수 있고, 서명자의 신원도 검증된다.

4. **전자 서명의 응용 사례:**
   - **SSL/TLS 프로토콜:** 웹사이트에서 HTTPS로 보안 연결을 설정할 때, 서버의 인증서에 포함된 전자 서명이 사용된다. 이를 통해 클라이언트는 서버의 신원을 검증하고, 안전한 연결을 수립할 수 있다.
   - **이메일 보안:** S/MIME와 같은 이메일 보안 프로토콜에서 전자 서명을 사용하여 이메일 발신자의 신원을 검증하고, 이메일 내용이 변조되지 않았음을 보장한다.
   - **디지털 계약서:** 전자 서명은 법적 효력을 가진 디지털 문서에 서명을 제공하여, 종이 문서와 동일한 법적 구속력을 갖게 한다.

### 요약

컴퓨터 네트워크 관점에서 전자 서명은 데이터 전송 시 기밀성, 무결성, 그리고 인증을 보장하는 핵심 기술이다. 전자 서명은 비대칭키 암호화 방식을 기반으로 하며, 네트워크 상에서 송신자의 신원을 검증하고 데이터의 무결성을 확인할 수 있도록 한다. 이를 통해 전자 서명은 안전한 통신과 신뢰성 있는 데이터 교환을 가능하게 한다.

## HTTPS 암호화 과정에 대해 설명해주세요. (SSL Handshake의 동작 과정을 설명해 주세요.)

1. **ClientHello 단계:**

   - HTTPS 통신이 시작되면, 클라이언트(예: 웹 브라우저)는 서버에 연결을 요청하면서 `ClientHello` 메시지를 보낸다.
   - 이 메시지에는 클라이언트가 지원하는 SSL/TLS 버전, 사용할 수 있는 암호화 알고리즘 목록(암호군, Cipher Suites), 클라이언트의 세션 ID, 압축 방법, 무작위 난수(Random Number) 등이 포함된다.
   - 이 정보를 통해 서버는 클라이언트가 사용할 수 있는 보안 옵션을 알게 된다.

2. **ServerHello 단계:**

   - 서버는 `ClientHello` 메시지를 받고 나서, 클라이언트와 사용할 SSL/TLS 버전, 암호화 알고리즘, 세션 ID 등을 결정한 후 `ServerHello` 메시지를 클라이언트에게 응답으로 보낸다.
   - 이 메시지에는 서버가 선택한 암호화 알고리즘, 서버의 세션 ID, 서버의 무작위 난수(Random Number) 등이 포함된다.
   - 또한, 서버는 자신의 인증서(서버 인증서)를 함께 전송한다. 이 인증서는 서버의 공개키를 포함하며, 공인된 인증 기관(CA, Certificate Authority)에 의해 서명되어 있다.

3. **서버 인증 및 공개키 교환:**

   - 클라이언트는 서버의 인증서를 받아서, 인증서가 신뢰할 수 있는 CA에 의해 서명되었는지, 인증서가 유효한지, 서버의 도메인 이름과 일치하는지 확인한다.
   - 이 과정이 성공적으로 완료되면, 클라이언트는 서버가 신뢰할 수 있다고 판단하고, 서버의 공개키를 사용해 다음 단계를 진행한다.

4. **Pre-Master Secret 생성:**

   - 클라이언트는 일회용 대칭키를 생성하는 데 사용될 `Pre-Master Secret`을 생성한다.
   - 이 `Pre-Master Secret`은 서버의 공개키로 암호화되어 서버로 전송된다. 이 과정에서 비대칭키 암호화가 사용되므로, 오직 서버만이 자신의 개인키를 사용해 이 정보를 복호화할 수 있다.

5. **세션 키 생성:**

   - 서버는 자신의 개인키로 클라이언트가 전송한 `Pre-Master Secret`을 복호화한다.
   - 이후, 클라이언트와 서버는 각각 `ClientHello`와 `ServerHello` 메시지에서 교환한 난수와 `Pre-Master Secret`을 결합하여 동일한 세션 키(Session Key)를 생성한다.
   - 이 세션 키는 대칭키 암호화 방식으로 이후의 데이터 전송을 암호화하는 데 사용된다. 대칭키 암호화는 비대칭키 암호화보다 훨씬 빠르기 때문에, 데이터 전송의 효율성을 높인다.

6. **Client Finished 및 Server Finished 메시지:**

   - 세션 키가 생성된 후, 클라이언트는 세션 키를 사용해 `Finished` 메시지를 암호화하여 서버에 보낸다. 이 메시지는 클라이언트가 핸드셰이크 과정을 성공적으로 완료했음을 의미한다.
   - 서버도 동일한 세션 키로 `Finished` 메시지를 클라이언트에 보내며, 이로써 서버도 핸드셰이크 과정을 완료했음을 알린다.

7. **암호화된 통신 시작:**

   - 핸드셰이크가 성공적으로 완료되면, 클라이언트와 서버는 세션 키를 사용해 이후의 모든 데이터를 암호화하여 주고받는다.
   - 이 과정에서 기밀성(암호화된 데이터 전송), 무결성(데이터 변조 방지), 그리고 인증(상호 신뢰 보장)이 보장된다.

8. **세션 종료:**
   - HTTPS 연결이 종료되면, 클라이언트와 서버는 `Close Notify` 메시지를 주고받아 연결을 안전하게 종료한다.
   - 이로써 세션 키가 폐기되며, 이후의 데이터는 더 이상 전송되지 않는다.

### 요약

SSL/TLS Handshake는 HTTPS에서 안전한 연결을 수립하기 위한 필수적인 과정이다. 이 과정에서는 클라이언트와 서버 간의 암호화 알고리즘을 협상하고, 안전한 세션 키를 교환하여 데이터 전송의 기밀성, 무결성, 인증을 보장한다. 이를 통해 사용자는 인터넷 상에서 안전하게 데이터를 주고받을 수 있다.

#  DNS

## DNS가 뭔가요?

> DNS(Domain Name System)는 도메인 이름을 IP 주소로 변환해주는 시스템이다.  
> 인간이 기억하기 쉬운 도메인 이름(예: www.naver.com )을 사용해 웹사이트에 접근하면,  
> DNS가 해당 도메인에 대응하는 IP 주소(예: 192.0.2.1)를 찾아 서버와 연결할 수 있도록 한다.  
> DNS는 인터넷의 전화번호부와 같은 역할을 한다.

## DNS 작동 방식에 대해 설명해주세요.

1. 사용자가 도메인 이름을 입력: 사용자가 웹 브라우저에 도메인 이름을 입력합니다.
2. 로컬 DNS 캐시 확인: 먼저, 사용자의 컴퓨터나 로컬 네트워크에 캐시된 DNS 정보가 있는지 확인합니다.
3. 재귀적 질의: 캐시가 없으면 로컬 DNS 서버에 질의를 보내고, 로컬 DNS 서버는 여러 DNS 서버를 차례로 조회합니다  
   (재귀적 질의)  
    이는 루트 DNS 서버, 최상위 도메인(TLD) DNS서버, 그리고 권한 있는 DNS 서버로 이어집니다.
4. IP 주소 반환: 최종적으로 권한 있는 DNS 서버가 도메인 이름에 대응하는 IP 주소를 찾아 반환하며, 로컬 DNS 서버가 이를 사용자에게 전달합니다.
5. 웹사이트 연결: 사용자는 IP 주소를 통해 웹 서버에 연결됩니다.

## DNS 질의 종류에 대해 설명해주세요.

### 재귀적 질의(Recursive Query)

> 클라이언트가 DNS 서버에 요청을 보낼 때, 요청된 도메인 이름에 대한 최종 IP 주소를 찾을 때까지 DNS 서버가 다른 DNS 서버에 재귀적으로 질의를 수행한다.

### 반복적 질의(Iterative Query)

> DNS 서버가 클라이언트에게 해당 도메인 이름에 대한 IP 주소를 직접 반환하지 않고, 다음으로 질의해야 할 DNS 서버의 주소를 알려준다.  
> 클라이언트는 여러 DNS 서버에 반복적으로 질의하여 최종 IP 주소를 얻는다.

## DNS 서버에게 IP 주소를 요청할 때, 왜 UDP를 사용하나요?

> DNS 질의는 일반적으로 작은 크기의 데이터 패킷을 빠르게 전송해야 하므로, 속도가 중요 요소이다.  
>  UDP는 연결을 설정하는 오버헤드가 없고, 전송 속도가 빠르기 때문에 주로 사용된다.  
>  또한 DNS 응답은 보통 512바이트 이내로 작아서 UDP의 패킷 크기 제한에도 문제가 없다.  
> 다만, DNSSEC 같은 경우에는 응답 데이터가 커질 수 있어 TCP가 사용되기도 한다.

## DNS 레코드가 무엇인가요?

> DNS 레코드는 도메인 이름과 관련된 다양한 정보를 저장하는 데이터베이스 항목이다.

```markdown
A 레코드: 도메인 이름을 IPv4 주소로 매핑한다.
AAAA 레코드: 도메인 이름을 IPv6 주소로 매핑한다.
CNAME 레코드: 도메인 이름을 다른 도메인 이름으로 매핑한다(별칭 생성).
MX 레코드: 도메인과 연관된 메일 서버 정보를 지정한다.
TXT 레코드: 도메인에 대한 텍스트 정보를 저장합니다. SPF, DKIM 같은 이메일 보안에 사용되기도 한다.
NS 레코드: 해당 도메인에 대한 권한 있는 네임 서버를 지정한다.
```

\*\* 혼자공부하는네트워크 - 강민철 저자님 도서를 참고하였습니다.  
\*\*https://velog.io/@soopy368/web-Get%EA%B3%BC-Post%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90
