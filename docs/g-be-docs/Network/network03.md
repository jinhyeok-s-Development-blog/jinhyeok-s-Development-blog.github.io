---
siderbar_position: 1
---

# 3.0 Network

## 3주차

- [쿠키와 세션에 대해서 설명해주세요.](#쿠키와-세션에-대해서-설명해주세요)
- [JWT 토큰에 대해서 설명해주세요.](#jwt-토큰에-대해서-설명해주세요)
- [SOP와 CORS에 대해서 설명해주세요.](#sop와-cors에-대해서-설명해주세요)
- [REST에 대해서 설명해주세요. Restful API는 뭘까요?](#rest에-대해서-설명해주세요--restful-api는-뭘까요)
- [REST 제약 조건에 대해 설명해주세요.](#rest-제약-조건에-대해-설명해주세요)
- [URL, URI, URN 차이가 뭘까요?](#url-uri-urn-차이가-뭘까요)
- [XSS 공격이 무엇이고, 방어하는 방법을 설명해주세요.](#xss-공격이-무엇이고-방어하는-방법을-설명해주세요)
- [CSRF 공격이 무엇이고, 방어하는 방법을 설명해주세요.](#csrf-공격이-무엇이고-방어하는-방법을-설명해주세요)
- [SQL Injection 공격이 무엇이고, 방어하는 방법을 설명해주세요.](#sql-injection-공격이-무엇이고-방어하는-방법을-설명해주세요)
- [웹 캐시에 대해 설명해주세요.](#웹-캐시에-대해-설명해주세요)
- [프록시 서버에 대해서 설명해주세요.](#프록시-서버에-대해서-설명해주세요)
- [포워드 프록시에 대해서 설명해주세요.](#포워드-프록시에-대해서-설명해주세요)
- [리버스 프록시에 대해서 설명해주세요.](#리버스-프록시에-대해서-설명해주세요)
- [L7 로드 밸런서에 대해서 설명해주세요.](#l7-로드-밸런서에-대해서-설명해주세요)
- [커넥션 타임아웃과 리드 타임아웃에 대해 설명해주세요.](#커넥션-타임아웃과-리드-타임아웃에-대해-설명해주세요)

---

## 쿠키와 세션에 대해서 설명해주세요.

### 쿠키와 세션을 사용하는 이유

> HTTP 프로토콜의 특성이자 약점을 보완하기 위해 쿠키와 세션을 사용합니다.

HTTP 프로토콜은 **무상태 프로토콜**이기 때문에, 서버는 클라이언트의 이전 요청에 대한 정보를 기억하지 않습니다.  
이로 인해 사용자의 로그인 상태 유지, 사용자 맞춤 정보 제공 등의 기능을 구현하기 어려워집니다.  
이를 해결하기 위해 쿠키와 세션이 사용됩니다. 쿠키는 클라이언트 측에 데이터를 저장하고, 세션은 서버 측에 데이터를 저장하여,  
사용자의 상태 정보를 유지함으로써 웹 애플리케이션이 더욱 동적인 사용자 경험을 제공할 수 있게 합니다.

### 쿠키 (Cookie)

> 쿠키는 웹 브라우저에 의해 클라이언트 측에 저장되는 작은 데이터 조각입니다.  
> 주로 사용자의 상태 정보를 저장하여, 웹 애플리케이션이 사용자에 대한 정보를 유지할 수 있도록 돕습니다.

#### 쿠키의 특징

1. **클라이언트 저장:** 쿠키는 사용자의 브라우저에 저장되며, 서버는 클라이언트로부터 쿠키를 받아 정보를 확인합니다.
2. **자동 전송:** 사용자가 웹사이트에 재접속할 때, 브라우저는 해당 웹사이트에 자동으로 쿠키를 전송합니다.
3. **데이터 제한:** 쿠키는 일반적으로 4KB 이하의 데이터를 저장할 수 있으며, 브라우저별로 저장할 수 있는 쿠키 수에 제한이 있습니다.
4. **만료 기간 설정:** 쿠키에는 만료 기간을 설정할 수 있으며, 이 기간이 지나면 쿠키는 자동으로 삭제됩니다.
5. **보안 취약점:** 쿠키는 클라이언트 측에 저장되기 때문에, 민감한 정보를 저장하는 것은 위험할 수 있습니다. 이러한 정보는 암호화된 형태로 저장해야 합니다.

#### 쿠키의 사용 예

- 사용자의 로그인 상태 유지
- 사용자 선호 설정 저장 (예: 언어 설정)
- 장바구니 정보 저장

#### 쿠키의 단점

1. **보안 문제:** 쿠키는 클라이언트 측에 저장되므로, 악의적인 사용자가 쿠키를 탈취하거나 변조할 수 있습니다. 따라서 중요한 정보는 쿠키에 저장하는 것을 피해야 합니다.
2. **제한된 저장 용량:** 쿠키는 데이터 저장 용량이 제한적이므로, 많은 양의 데이터를 저장하기에 부적합합니다.
3. **브라우저 의존성:** 사용자가 쿠키를 차단하거나 삭제하면, 웹 애플리케이션의 상태 유지가 어려워질 수 있습니다.

### 세션 (Session)

> 세션은 서버 측에서 관리되는 사용자 상태 정보를 의미합니다.  
> 세션은 사용자와 서버 간의 연결을 유지하고, 사용자가 웹사이트를 탐색하는 동안 상태를 유지하기 위해 사용됩니다.

#### 세션의 특징

1. **서버 저장:** 세션은 서버에서 관리되며, 클라이언트에는 세션 ID만 쿠키로 저장되어 서버와의 통신 시 사용됩니다.
2. **브라우저 종료 시 만료:** 세션은 일반적으로 브라우저를 종료하면 만료되지만, 서버 설정에 따라 세션 유지 시간이 달라질 수 있습니다.
3. **보안성:** 세션은 서버에 저장되기 때문에, 클라이언트가 직접 접근하거나 수정할 수 없어 비교적 안전합니다.
4. **사용량 제한:** 많은 사용자가 동시에 접속할 경우, 서버의 메모리를 많이 사용하게 되므로, 세션 관리에 주의가 필요합니다.

#### 세션의 사용 예

- 사용자 인증 상태 유지 (로그인 후 페이지 이동 시 인증 상태 유지)
- 사용자 활동 기록 관리 (예: 최근 본 상품)

#### 세션의 단점

1. **서버 부하:** 세션은 서버 메모리에 저장되므로, 많은 사용자가 동시에 접속할 경우 서버에 부하가 걸릴 수 있습니다.
2. **유지 비용:** 세션을 유지하기 위해서는 서버 측에서 메모리와 스토리지를 지속적으로 사용해야 하므로, 자원 관리가 필요합니다.
3. **브라우저 의존성:** 세션은 브라우저가 종료되면 기본적으로 만료되므로, 사용자가 세션 유지 시간을 초과하거나 브라우저를 닫으면 세션이 만료될 수 있습니다.

### 쿠키와 세션의 차이점

- **저장 위치:** 쿠키는 클라이언트 측에, 세션은 서버 측에 저장됩니다.
- **보안성:** 세션이 쿠키보다 보안성이 높습니다.
- **유지 시간:** 쿠키는 만료 기간을 지정할 수 있지만, 세션은 일반적으로 브라우저 종료 시 만료됩니다.
- **데이터 저장 용량:** 쿠키는 제한된 데이터 양(약 4KB)을 저장할 수 있는 반면, 세션은 서버의 메모리와 스토리지에 따라 달라집니다.

## JWT 토큰에 대해서 설명해주세요.

### JWT 토큰

> JWT(JSON Web Token)는 두 개체 간에 JSON 객체를 사용하여 정보를 안전하게 전송하기 위한 **토큰**입니다.  
> JWT는 주로 인증과 권한 부여에서 사용되며, 클라이언트와 서버 간의 신뢰할 수 있는 정보 교환을 가능하게 합니다.

### JWT의 구조

JWT는 `.`으로 구분된 세 부분으로 구성됩니다.

1. **Header (헤더):**
   - 헤더는 토큰의 타입과 해싱 알고리즘 정보를 포함합니다.
   - 일반적으로 두 가지 정보가 포함됩니다:
     - `typ`: 토큰의 타입, JWT일 경우 `JWT`로 설정됩니다.
     - `alg`: 해싱 알고리즘, 보통 `HMAC SHA256` 또는 `RSA`가 사용됩니다.

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

2. **Payload (페이로드):**
   - 페이로드에는 JWT에 담길 클레임(Claims)들이 포함됩니다.
   - 클레임은 사용자의 정보(예: 사용자 ID)와 토큰의 만료 시간 등 여러 속성을 담을 수 있습니다.
   - 페이로드에는 보통 아래와 같은 클레임들이 포함됩니다:
     - `iss`: 토큰 발행자(Issuer)
     - `sub`: 토큰의 대상(Subject)
     - `exp`: 토큰의 만료 시간(Expiration)
     - `aud`: 토큰의 대상자(Audience)

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true,
  "exp": 1516239022
}
```

3. **Signature (서명):**
   - 서명은 JWT의 무결성을 보장합니다.
   - 서명은 헤더와 페이로드를 인코딩한 후, 주어진 비밀 키를 사용해 서명합니다.
   - 서명은 헤더와 페이로드의 조합을 해싱 알고리즘으로 암호화하여 생성됩니다.
   ```json
     HMACSHA256(
     base64UrlEncode(header) + "." +
     base64UrlEncode(payload),
     secret
     )
   ```

## JWT의 동작 방식

1. **토큰 발급:**
   - 사용자가 로그인하면, 서버는 사용자의 정보를 기반으로 JWT를 생성하여 클라이언트에게 전달합니다.
2. **토큰 저장:**
   - 클라이언트는 JWT를 일반적으로 로컬 스토리지 또는 쿠키에 저장합니다.
3. **토큰 전송:**
   - 이후 클라이언트가 서버에 요청을 보낼 때, JWT를 요청 헤더의 `Authorization` 필드에 포함시켜 전송합니다.
   - 예: `Authorization: Bearer <JWT_TOKEN>`
4. **토큰 검증:**
   - 서버는 요청을 받을 때, 해당 JWT의 서명을 검증하여 유효한 토큰인지 확인합니다.
   - 유효한 토큰일 경우, 서버는 페이로드에 포함된 사용자 정보를 바탕으로 요청을 처리합니다.

## JWT의 장점

- **독립적:** JWT는 자가 포함(self-contained)되어 있어, 필요한 정보를 토큰 자체에 포함할 수 있습니다.
- **무상태성:** JWT는 서버 측 세션을 필요로 하지 않으므로, 무상태성을 유지할 수 있어 확장성이 높습니다.
- **안전성:** JWT는 서명된 토큰이기 때문에, 클라이언트에서 데이터를 변조할 수 없습니다.
- **유연성:** 다양한 클라이언트 및 서버 간의 인증 방식으로 사용될 수 있으며, OAuth 2.0과 같은 인증 프로토콜에서도 활용됩니다.

## JWT의 단점

- **페이로드 노출:** 페이로드는 Base64로 인코딩되므로, 누구나 디코딩하여 내용을 볼 수 있습니다. 따라서 민감한 정보는 페이로드에 포함시키지 않는 것이 좋습니다.
- **토큰 크기:** JWT는 세 부분으로 구성되므로, 일반 쿠키나 세션보다 크기가 커질 수 있습니다.
- **만료 관리:** JWT는 발급되면 만료 전까지 유효하기 때문에, 강제 로그아웃 등을 처리하기 어려울 수 있습니다.

## JWT 사용 예

- **사용자 인증:** 사용자가 로그인하면 서버는 JWT를 생성하여 클라이언트에게 전달하고, 이후 요청 시마다 이 JWT를 사용해 인증을 수행합니다.
- **API 접근 제어:** JWT를 사용하여 API 접근 권한을 제어할 수 있습니다. 클라이언트는 API 요청 시 JWT를 포함하고, 서버는 JWT를 검증하여 접근을 허용하거나 거부합니다.

## SOP와 CORS에 대해서 설명해주세요.

### SOP (Same-Origin Policy)

> **SOP**(Same-Origin Policy)는 웹 보안 모델 중 하나로, 브라우저에서 로드된 문서나 스크립트가 다른 출처의 리소스에 접근하는 것을 제한하는 보안 정책입니다.  
> SOP는 악의적인 웹 사이트가 다른 웹 사이트의 중요한 데이터를 훔치거나 조작하는 것을 방지하기 위해 설계되었습니다.

#### SOP의 특징

1. **동일 출처 제한:** SOP에 따르면, 동일한 출처(Origin)에서 로드된 리소스만 서로 접근할 수 있습니다.  
   출처는 **프로토콜**, **호스트**(도메인), **포트**의 조합으로 정의됩니다. 이 세 가지 요소가 모두 일치해야 동일한 출처로 간주됩니다.
2. **보안 강화:** SOP는 크로스사이트 요청 위조(CSRF) 및 크로스사이트 스크립팅(XSS)과 같은 공격을 방지하여 웹 애플리케이션의 보안을 강화합니다.

3. **제한 사항:** SOP는 보안상 중요한 규칙이지만, 개발 시 API 호출이나 외부 리소스 접근에 제약을 줄 수 있습니다.

#### SOP의 예시

- `https://example.com`에서 로드된 스크립트는 동일한 출처의 리소스인 `https://example.com/api/data`에는 접근할 수 있지만, `https://another.com/api/data`에는 접근할 수 없습니다.

### CORS (Cross-Origin Resource Sharing)

> **CORS**(Cross-Origin Resource Sharing)는 웹 애플리케이션이 서로 다른 출처에서 리소스를 공유할 수 있도록 허용하는 보안 기능입니다.  
> CORS는 SOP의 제한을 우회할 수 있도록 설계되었으며, 서버가 특정 출처에서 오는 요청을 허용할 수 있도록 설정할 수 있습니다.

#### CORS의 특징

1. **헤더 기반 제어:** CORS는 서버 측에서 설정된 HTTP 헤더를 통해 클라이언트가 어떤 출처에서 리소스에 접근할 수 있는지를 제어합니다.  
   서버는 `Access-Control-Allow-Origin` 헤더를 사용해 허용된 출처를 지정할 수 있습니다.

2. **프리플라이트 요청:**

   - CORS 요청 중 안전하지 않은 메서드(예: `POST`, `PUT`, `DELETE`)를 사용하거나, 특별한 헤더를 포함한 요청을 보낼 때, 브라우저는 사전에 `OPTIONS` 메서드로 프리플라이트(preflight) 요청을 보냅니다.
   - 이 프리플라이트 요청에 대한 응답에서 서버가 허용된 메서드와 헤더를 명시하면, 이후의 실제 요청이 실행됩니다.

3. **보안 강화와 유연성:**
   - CORS는 SOP로 인해 발생하는 제한을 풀어주는 동시에, 서버가 승인한 출처만 리소스에 접근할 수 있도록 허용하여 보안을 유지합니다.

#### CORS의 예시

- 서버가 `Access-Control-Allow-Origin: https://another.com` 헤더를 응답에 포함시키면, `https://another.com`에서 오는 요청은 SOP를 우회하여 서버의 리소스에 접근할 수 있습니다.
- 만약 `Access-Control-Allow-Origin` 헤더에 `*`를 설정하면, 모든 출처에서 오는 요청을 허용하게 됩니다.

## REST에 대해서 설명해주세요. Restful API는 뭘까요?

### REST (Representational State Transfer)

> **REST**(Representational State Transfer)는 네트워크 상에서 자원을 정의하고 자원에 대한 주소를 지정하는 아키텍처 스타일입니다.  
> REST는 주로 HTTP 프로토콜을 기반으로 클라이언트와 서버 간의 통신을 간소화하고, 웹 서비스 개발에 널리 사용됩니다.

#### REST의 특징

1. **자원(Resource) 기반 설계:**

   - REST는 웹 서비스의 모든 것을 자원(Resource)으로 간주하며, 각각의 자원은 고유한 URI로 식별됩니다.
   - 예를 들어, `https://api.example.com/users/123`은 ID가 123인 사용자를 나타내는 자원입니다.

2. **HTTP 메서드 사용:**

   - REST는 자원에 대한 작업을 HTTP 메서드를 통해 표현합니다. 일반적으로 사용되는 메서드는 다음과 같습니다:
     - `GET`: 자원의 조회
     - `POST`: 자원의 생성
     - `PUT`: 자원의 전체 수정
     - `PATCH`: 자원의 부분 수정
     - `DELETE`: 자원의 삭제

3. **무상태성(Stateless):**

   - REST는 클라이언트의 상태를 서버에 저장하지 않으며, 각 요청은 독립적이고 완결된 형태로 전송됩니다.
   - 서버는 각 요청을 별도로 처리하며, 이전 요청과의 연결이나 상태를 기억하지 않습니다.

4. **캐시 가능성:**

   - REST API는 응답을 캐시할 수 있어, 네트워크 트래픽을 줄이고 성능을 향상시킬 수 있습니다.
   - HTTP 헤더를 통해 캐싱을 제어할 수 있습니다.

5. **계층형 구조:**

   - REST는 클라이언트와 서버 사이에 중간 계층(예: 로드 밸런서, 프록시 서버)을 두어 시스템의 유연성과 보안을 높일 수 있습니다.

6. **인터페이스의 일관성:**
   - REST는 일관된 인터페이스를 통해 다양한 클라이언트가 동일한 방식으로 자원에 접근할 수 있도록 합니다.

### RESTful API

> **RESTful API**는 REST 아키텍처 스타일을 따르는 API(Application Programming Interface)입니다.  
> RESTful API는 REST의 원칙을 준수하여 설계된 웹 서비스로, 클라이언트와 서버 간의 데이터 교환을 효율적으로 처리합니다.

#### RESTful API의 특징

1. **명확한 자원 경로:**

   - RESTful API는 자원을 URI로 명확히 식별합니다. 예를 들어, `/users/123`은 ID가 123인 사용자 자원을 나타냅니다.
   - 자원 경로는 직관적이고 의미 있게 설계되어야 합니다.

2. **HTTP 메서드 사용:**

   - RESTful API는 HTTP 메서드를 사용하여 자원에 대한 CRUD(Create, Read, Update, Delete) 작업을 처리합니다.
   - 예를 들어, `GET /users`는 모든 사용자를 조회하고, `POST /users`는 새로운 사용자를 생성하는 요청입니다.

3. **상태 코드 사용:**

   - RESTful API는 요청의 결과를 HTTP 상태 코드로 반환합니다. 예를 들어, `200 OK`는 요청이 성공했음을, `404 Not Found`는 요청한 자원을 찾을 수 없음을 의미합니다.

4. **무상태성:**

   - RESTful API는 무상태성을 유지하여, 각 요청이 독립적이고 서버에 상태를 저장하지 않도록 설계됩니다.
   - 클라이언트는 필요한 모든 정보를 요청과 함께 서버에 보내야 합니다.

5. **자원 표현(Representation):**

   - RESTful API는 자원을 다양한 형식으로 표현할 수 있으며, 일반적으로 JSON이나 XML이 사용됩니다.
   - 클라이언트는 `Accept` 헤더를 사용해 원하는 데이터 형식을 요청할 수 있습니다.

6. **URI 설계 규칙:**
   - RESTful API는 자원 이름에 복수형을 사용하며, URI는 소문자로 작성됩니다.
   - 예: `/users`, `/products/123`

#### RESTful API의 장점

- **유연성:** RESTful API는 다양한 클라이언트와 쉽게 호환될 수 있으며, 웹, 모바일, IoT 등의 다양한 환경에서 사용할 수 있습니다.
- **확장성:** RESTful API는 확장성이 뛰어나며, 새로운 기능을 추가하거나 기존 기능을 확장하기 쉽습니다.
- **표준화:** HTTP 표준을 따르기 때문에, 전 세계적으로 널리 사용되며 일관된 API 설계가 가능합니다.

#### RESTful API의 단점

- **복잡성:** 단순한 요구사항에는 RESTful API가 과도할 수 있으며, 복잡한 요구사항을 구현하는 데 어려움이 있을 수 있습니다.
- **오버헤드:** HTTP 요청과 응답에 따른 오버헤드가 발생할 수 있으며, 무상태성으로 인해 일부 작업에서는 비효율적일 수 있습니다.

## REST 제약 조건에 대해 설명해주세요.

### REST 제약

REST(Representational State Transfer) 아키텍처 스타일은 여러 가지 제약 조건을 따르며, 이를 통해 확장성, 성능, 신뢰성 등을 보장합니다. REST의 제약 조건은 다음과 같습니다:

1. **클라이언트-서버 구조 (Client-Server Architecture):**

   - 클라이언트와 서버는 명확히 분리되어야 합니다.
   - 클라이언트는 사용자 인터페이스와 사용자 경험에 집중하고, 서버는 데이터 저장과 비즈니스 로직 처리에 집중합니다.
   - 이 구조는 확장성을 높이고, 클라이언트와 서버를 독립적으로 개선할 수 있도록 합니다.

2. **무상태성 (Stateless):**

   - 각 요청은 독립적이어야 하며, 서버는 이전 요청의 상태를 기억하지 않습니다.
   - 클라이언트는 필요한 모든 정보를 요청에 포함시켜야 합니다.
   - 이 제약은 서버의 확장성과 성능을 개선할 수 있지만, 클라이언트가 더 많은 책임을 지게 됩니다.

3. **캐시 가능성 (Cacheable):**

   - 서버 응답은 캐시할 수 있어야 하며, 클라이언트는 이를 통해 재사용할 수 있습니다.
   - 응답 메시지에는 해당 응답이 캐시 가능한지, 그리고 캐시할 수 있다면 얼마나 오래 캐시할 수 있는지를 나타내는 정보가 포함되어야 합니다.
   - 캐시는 네트워크 효율성을 높이고, 서버의 부하를 줄일 수 있습니다.

4. **계층화 시스템 (Layered System):**

   - 클라이언트와 서버 사이에 여러 계층(프록시, 게이트웨이 등)이 존재할 수 있으며, 각 계층은 서로 독립적으로 관리됩니다.
   - 클라이언트는 직접 서버와 통신하는지, 중간에 다른 계층이 있는지 알 필요가 없습니다.
   - 이 계층화 구조는 보안, 로드 밸런싱, 시스템 확장성 등을 개선할 수 있습니다.

5. **일관된 인터페이스 (Uniform Interface):**

   - REST는 모든 상호작용이 일관된 인터페이스를 통해 이루어져야 한다고 규정합니다.
   - 일관된 인터페이스는 API 설계의 단순성과 일관성을 유지하는 데 도움이 됩니다.
   - 주요 구성 요소:
     - **자원의 식별:** 자원은 고유한 URI로 식별됩니다.
     - **자원의 표현:** 클라이언트는 자원의 표현을 통해 상호작용하며, 서버는 자원의 상태를 클라이언트에게 전달합니다.
     - **자원의 조작:** 클라이언트는 자원의 표현을 수정하거나 전송하여 자원을 조작합니다.
     - **하이퍼미디어(HATEOAS):** 자원 간의 링크를 통해 클라이언트가 동적으로 상호작용할 수 있습니다.

6. **Code on Demand (선택적):**
   - 클라이언트 기능을 확장하기 위해 서버에서 코드를 다운로드하여 실행할 수 있는 기능입니다.
   - 자바스크립트 같은 스크립트가 클라이언트로 전송되어 실행될 수 있습니다.
   - 이 제약 조건은 선택적이며, 모든 RESTful 시스템에서 필수적으로 구현될 필요는 없습니다.

## URL, URI, URN 차이가 뭘까요?

### URL (Uniform Resource Locator)

> **URL**은 인터넷 상에서 자원이 위치하는 주소를 나타냅니다.  
> URL은 자원의 위치(로케이터)를 설명하며, 주로 웹 페이지, 파일, 이미지 등의 위치를 나타내는 데 사용됩니다.

#### URL의 구성 요소

- **프로토콜:** 자원에 접근하기 위한 통신 규약을 나타냅니다. 예: `http`, `https`, `ftp`
- **호스트:** 자원이 위치한 서버의 도메인 이름 또는 IP 주소입니다. 예: `www.example.com`
- **포트 번호:** 서버가 요청을 수신하는 포트를 나타냅니다. 예: `:80` (생략 가능)
- **경로:** 서버 내에서 자원의 위치를 나타내는 경로입니다. 예: `/path/to/resource`
- **쿼리 문자열:** 자원에 대한 추가적인 데이터를 전달하는 부분입니다. 예: `?key1=value1&key2=value2`

#### URL 예시

`https://www.example.com:443/path/to/resource?key1=value1`

### URI (Uniform Resource Identifier)

> **URI**는 인터넷 상에서 자원을 식별하는 방법을 나타내며, URL과 URN을 포함하는 상위 개념입니다.  
> URI는 자원의 위치 또는 이름을 나타낼 수 있으며, 자원을 고유하게 식별할 수 있습니다.

#### URI의 구성 요소

- **스킴(Scheme):** 자원을 식별하는 방식이나 프로토콜을 정의합니다. 예: `http`, `https`, `urn`
- **식별자:** 자원의 위치 또는 이름을 나타냅니다.

#### URI 예시

- URL: `https://www.example.com/path/to/resource`
- URN: `urn:isbn:0451450523`

### URN (Uniform Resource Name)

> **URN**은 자원의 이름을 식별하는 데 사용되는 URI의 한 종류입니다.  
> URN은 자원의 위치와 상관없이 자원을 고유하게 식별할 수 있도록 설계되었습니다.

#### URN의 특징

- **위치 독립적:** URN은 자원의 위치에 영향을 받지 않으며, 자원의 이름만을 기반으로 고유하게 식별합니다.
- **고유성:** URN은 전 세계에서 고유한 식별자로 사용될 수 있습니다.

#### URN 예시

`urn:isbn:0451450523` (이 ISBN 번호는 특정 책을 식별합니다)

---

### URL, URI, URN의 차이

- **URI:** 자원을 식별하는 모든 방식의 상위 개념으로, URL과 URN을 포함합니다.
- **URL:** 자원의 위치를 나타내는 URI의 하위 개념으로, 특정 자원의 접근 경로를 제공합니다.
- **URN:** 자원의 이름을 나타내는 URI의 하위 개념으로, 자원을 고유하게 식별합니다.

URL은 자원의 위치를 가리키고, URN은 자원의 이름을 가리키며, URI는 이 둘을 포함한 모든 자원의 식별자를 의미합니다.

## XSS 공격이 무엇이고, 방어하는 방법을 설명해주세요.

### XSS 공격

> XSS(Cross-Site-Scripting)란 다른 웹사이트와 정보를 교환하는 것으로,XSS 공격은 간단하게 말하자면, 웹 애플리게이션에서 웹사이트 관리자가 아닌 이가 웹 페이지에 악성 스크립트를 삽입하는 것을 말한다.

#### XSS 공격의 유형

1. **저장형 XSS (Stored XSS):**

   - 공격자가 악성 스크립트를 웹 애플리케이션의 데이터베이스에 저장시키고, 이후 해당 데이터를 조회하는 사용자들에게 스크립트가 실행되도록 하는 방식입니다.
   - 예: 게시판이나 댓글 시스템에 악성 스크립트를 작성하여 저장시키는 경우.

2. **반사형 XSS (Reflected XSS):**

   - 사용자가 입력한 데이터가 서버로 전송된 후, 다시 웹 페이지에 반사되어 출력될 때 발생합니다.
   - 주로 URL 매개변수나 폼 입력 값을 통해 스크립트가 전송됩니다.
   - 예: 검색 결과 페이지에서 입력된 검색어를 그대로 출력할 때 발생하는 XSS.

3. **DOM 기반 XSS (DOM-based XSS):**
   - 클라이언트 측에서 실행되는 자바스크립트가 DOM(Document Object Model) 요소를 다루는 과정에서 발생하는 XSS입니다.
   - 서버로부터 전송된 응답과 상관없이, 클라이언트 측에서 자바스크립트가 악성 스크립트를 실행하게 됩니다.

### XSS 방어

> 1. 정규표현식 사용 - 특수문자를 입력받지 못하도록 처리

```java
function defenseXSS() {
const text = document.querySelector("input[name=todo]");
const regex = /^[ㄱ-ㅎ|가-힣|a-z|A-Z|0-9| |]+$/;
            if (!regex.test(text.value)) {
                alert('특수 문자는 입력할 수 없습니다.');
                return false;
            }
            return true;
        }
```

> 2. 입력값 치환 - 특수문자를 문자열로 치환하기

```java
value = value.replaceAll("<", "&lt;");
value = value.replaceAll(">", "&gt;");
value = value.replaceAll("\\(", "&#40;")
value = value.replaceAll("\\)", "&#41;");
value = value.replaceAll("'", "&#x27;");
```

> 3. 직접출력 금지 - c:out을 이용하여 그대로 문자열로 출력하도록 하기

<c:out value="${keyword}"/>

## CSRF 공격이 무엇이고, 방어하는 방법을 설명해주세요.

### CSRF 공격

> **CSRF(Cross-Site Request Forgery)**는 사용자가 의도하지 않은 행동을 강제로 수행하도록 하는 웹 보안 공격 기법입니다.  
> CSRF 공격은 사용자가 특정 웹사이트에 로그인한 상태에서 악의적인 웹사이트를 방문했을 때 발생할 수 있습니다.  
> 공격자는 피해자가 의도하지 않은 요청을 하도록 유도하여, 사용자의 권한으로 서버에 악성 요청을 전송하게 만듭니다.

#### CSRF 공격의 동작 원리

1. 사용자가 신뢰할 수 있는 웹사이트에 로그인합니다.
2. 공격자가 악성 스크립트가 포함된 링크 또는 이미지를 사용자에게 보내거나, 사용자가 공격자의 웹사이트를 방문하도록 유도합니다.
3. 사용자가 악성 링크를 클릭하거나 악성 웹사이트를 방문하면, 브라우저는 자동으로 사용자의 세션 정보를 포함한 요청을 신뢰할 수 있는 웹사이트에 전송합니다.
4. 신뢰할 수 있는 웹사이트는 이 요청이 사용자에 의해 의도된 것이라고 믿고, 요청을 처리하게 됩니다.
5. 결과적으로 사용자는 자신이 의도하지 않은 행동(예: 비밀번호 변경, 송금 등)을 수행하게 됩니다.

### CSRF 방어

CSRF 공격을 방어하기 위해서는 다음과 같은 방법들을 사용할 수 있습니다:

1. **CSRF 토큰 사용:**

   - 서버는 사용자 세션과 연관된 고유한 CSRF 토큰을 생성하여, 모든 민감한 요청에 이 토큰을 포함하도록 합니다.
   - 서버는 요청 시 이 토큰의 유효성을 검증하여, 토큰이 없는 요청이나 잘못된 토큰이 포함된 요청을 차단합니다.

   예시:

```sql
   <form method="POST" action="/update-profile">

       <input type="hidden" name="csrf_token" value="unique_token_here">

       <!-- 다른 폼 입력 요소들 -->

   </form>
```

2. **Referer 헤더 검증:**

   - 서버는 요청이 들어올 때, `Referer` 헤더를 확인하여 요청이 올바른 출처에서 발생했는지 검증합니다.
   - 그러나 `Referer` 헤더는 일부 프라이버시 설정이나 네트워크 환경에 따라 누락될 수 있으므로, 이 방법만으로는 충분하지 않을 수 있습니다.

3. **SameSite 쿠키 속성 설정:**

   - 쿠키에 `SameSite` 속성을 설정하여, 동일한 출처에서 발생한 요청에 대해서만 쿠키를 전송하도록 제한할 수 있습니다.
   - 이 방법은 CSRF 공격을 상당 부분 방어할 수 있습니다.

   예시:

   Set-Cookie: sessionid=abc123; SameSite=Strict;

4. **정상적인 요청만 허용:**

   - 민감한 작업(예: 데이터 변경, 삭제 등)을 수행하는 요청은 반드시 `POST`, `PUT`, `DELETE`와 같은 메서드를 사용하도록 하며, `GET` 요청으로는 수행되지 않도록 합니다.
   - 이는 CSRF 공격이 일반적으로 `GET` 요청을 통해 이루어지는 것을 방지할 수 있습니다.

5. **이중 인증(2FA):**
   - 중요한 작업을 수행하기 전, 이중 인증을 요구하여, 사용자가 의도적으로 작업을 수행하는지 확인할 수 있습니다.
   - 이 방법은 CSRF 공격뿐만 아니라 여러 종류의 공격에 대한 추가적인 보안 계층을 제공합니다.

이와 같은 방법들을 조합하여 CSRF 공격에 대한 보안을 강화할 수 있습니다.

## SQL Injection 공격이 무엇이고, 방어하는 방법을 설명해주세요.

### SQL Injection 공격

> **SQL Injection**은 공격자가 웹 애플리케이션의 데이터베이스에 악의적인 SQL 코드를 삽입하여, 데이터베이스를 조작하거나 민감한 정보를 탈취하는 공격 기법입니다.  
> SQL Injection 공격은 웹 애플리케이션에서 사용자 입력을 제대로 검증하지 않을 때 발생하며, 데이터베이스의 무결성과 보안을 위협할 수 있습니다.

#### SQL Injection 공격의 동작 원리

1. 공격자는 웹 애플리케이션의 입력 필드(예: 로그인 폼, 검색 창 등)에 SQL 구문을 삽입합니다.
2. 웹 애플리케이션이 이 입력 값을 제대로 검증하지 않고 SQL 쿼리에 포함시키면, 데이터베이스에서 예상치 못한 명령이 실행될 수 있습니다.
3. 이를 통해 공격자는 데이터베이스의 데이터를 조회하거나, 삭제, 수정하는 등의 권한을 가질 수 있습니다.

#### SQL Injection의 예시

예를 들어, 아래와 같은 SQL 쿼리가 있다고 가정합니다:

```SQL
SELECT * FROM users WHERE username = 'admin' AND password = 'password';
```

공격자가 `username` 필드에 `' OR '1'='1`와 같은 값을 입력하면, 쿼리는 다음과 같이 변경됩니다:

```SQL
SELECT * FROM users WHERE username = 'admin' OR '1'='1' AND password = 'password';
```

이 쿼리는 항상 참이 되어, 공격자는 인증을 우회할 수 있습니다.

### SQL Injection 방어

SQL Injection 공격을 방어하기 위해서는 다음과 같은 방법들을 사용할 수 있습니다:

1. **준비된 쿼리문(Prepared Statements) 사용:**

   - 준비된 쿼리문을 사용하면, SQL 구문과 데이터가 분리되므로, 데이터가 쿼리문으로 해석되지 않습니다.
   - 이는 SQL Injection 공격을 효과적으로 방지할 수 있는 방법입니다.

   예시 (Java):

   ```SQL
   String query = "SELECT * FROM users WHERE username = ? AND password = ?";

   PreparedStatement pstmt = connection.prepareStatement(query);

   pstmt.setString(1, username);

   pstmt.setString(2, password);

   ResultSet rs = pstmt.executeQuery();
   ```

2. **입력값 검증 및 필터링:**

   - 모든 사용자 입력값을 철저히 검증하고 필터링하여, 악의적인 SQL 코드가 포함되지 않도록 해야 합니다.
   - 숫자 값에는 숫자만 허용하고, 문자열에는 예상된 패턴만 허용하는 등의 검증을 수행합니다.

3. **ORM(Object-Relational Mapping) 사용:**

   - ORM 프레임워크를 사용하면, SQL 쿼리를 직접 작성하지 않고도 데이터베이스와 상호작용할 수 있어, SQL Injection의 위험을 줄일 수 있습니다.
   - ORM은 내부적으로 SQL Injection 방지 메커니즘을 갖추고 있습니다.

4. **최소 권한 원칙 적용:**

   - 데이터베이스 사용자 계정에 최소한의 권한만 부여하여, 만약 공격자가 침입하더라도 피해를 최소화할 수 있도록 합니다.
   - 읽기 전용 계정, 쓰기 전용 계정 등으로 역할을 구분하여 사용합니다.

5. **에러 메시지 출력 제한:**

   - 공격자는 에러 메시지를 통해 데이터베이스 구조나 쿼리문에 대한 정보를 파악할 수 있습니다.
   - 따라서, 에러 메시지를 사용자에게 노출하지 않도록 하고, 내부적으로 처리하는 것이 좋습니다.

6. **정기적인 보안 점검 및 코드 리뷰:**
   - 정기적으로 보안 점검을 수행하여 SQL Injection 취약점을 조기에 발견하고 수정합니다.
   - 코드 리뷰를 통해 SQL 쿼리 작성 시 발생할 수 있는 실수를 방지합니다.

이러한 방어 방법들을 통해 SQL Injection 공격을 예방하고, 데이터베이스의 보안을 강화할 수 있습니다.

## 웹 캐시에 대해 설명해주세요

> **웹 캐시(Web Cache)**는 웹 브라우저나 프록시 서버가 웹 페이지나 자원을 저장해 두었다가, 이후 같은 요청이 들어왔을 때 원 서버에 다시 요청하지 않고 저장된 데이터를 제공하는 기술입니다.  
> 이를 통해 웹 서버의 부하를 줄이고, 사용자에게 더 빠른 응답을 제공할 수 있습니다.

### 웹 캐시의 종류

1. **브라우저 캐시:** 사용자의 브라우저가 웹 페이지와 자원을 캐시하여, 재방문 시 저장된 자원을 로드합니다.
2. **프록시 캐시:** 네트워크 상의 프록시 서버가 자원을 캐시하여, 여러 사용자에게 동일한 자원을 제공할 때 효율성을 높입니다.
3. **CDN 캐시:** 콘텐츠 배포 네트워크(CDN) 서버가 자원을 전 세계에 분산 캐시하여, 사용자에게 더 빠른 로딩 시간을 제공합니다.

### 웹 캐시의 장점

- **속도 향상:** 자주 요청되는 자원을 캐시하여 빠르게 제공함으로써, 사용자 경험을 개선합니다.
- **트래픽 감소:** 원 서버에 대한 요청을 줄여 네트워크 트래픽을 절감할 수 있습니다.
- **서버 부하 감소:** 서버에서 처리해야 할 요청 수가 줄어들어, 서버의 부하를 줄입니다.

## 프록시 서버에 대해서 설명해주세요

> **프록시 서버(Proxy Server)**는 클라이언트와 서버 사이에서 중계 역할을 하는 서버입니다.  
> 클라이언트의 요청을 받아 대신 서버에 전달하고, 서버의 응답을 받아 클라이언트에게 전달합니다.

### 프록시 서버의 역할

1. **보안 강화:** 프록시 서버를 통해 외부에서 클라이언트의 IP 주소를 숨기고, 직접적인 접근을 막아 보안을 강화할 수 있습니다.
2. **캐싱:** 자주 요청되는 데이터를 캐싱하여, 서버 부하를 줄이고 응답 속도를 높입니다.
3. **접근 제어:** 특정 웹사이트나 서비스에 대한 접근을 차단하거나 허용할 수 있습니다.
4. **트래픽 관리:** 대규모 네트워크에서 트래픽을 관리하고, 분산시키는 역할을 합니다.

## 포워드 프록시에 대해서 설명해주세요

> **포워드 프록시(Forward Proxy)**는 클라이언트의 요청을 서버로 전달하는 역할을 하는 프록시 서버입니다.  
> 주로 내부 네트워크 사용자가 외부 인터넷에 접근할 때 사용됩니다.

### 포워드 프록시의 특징

1. **클라이언트 보호:** 클라이언트의 IP 주소를 숨겨 외부 서버에서 클라이언트를 식별할 수 없도록 합니다.
2. **캐싱:** 외부 자원을 캐싱하여, 동일한 요청에 대해 더 빠른 응답을 제공합니다.
3. **접근 제어:** 내부 네트워크 사용자의 외부 인터넷 접근을 제어하거나 제한할 수 있습니다.

## 리버스 프록시에 대해서 설명해주세요

> **리버스 프록시(Reverse Proxy)**는 서버의 요청을 받아 클라이언트에게 전달하는 역할을 하는 프록시 서버입니다.  
> 주로 외부 클라이언트가 내부 서버에 접근할 때 사용됩니다.

### 리버스 프록시의 특징

1. **로드 밸런싱:** 여러 대의 서버에 트래픽을 분산시켜 서버 부하를 줄이고, 서비스 가용성을 높입니다.
2. **보안 강화:** 클라이언트가 직접 서버에 접근하지 못하도록 하여, 서버를 보호합니다.
3. **SSL 종료:** SSL 암호화 통신을 리버스 프록시에서 처리하여, 내부 서버의 부담을 줄입니다.
4. **캐싱:** 정적 콘텐츠를 캐싱하여, 서버의 응답 속도를 높이고 부하를 줄입니다.

## L7 로드 밸런서에 대해서 설명해주세요

> **L7 로드 밸런서**는 OSI 7계층의 애플리케이션 계층에서 동작하는 로드 밸런서입니다.  
> HTTP, HTTPS, FTP와 같은 애플리케이션 레벨의 프로토콜을 기반으로 트래픽을 분산합니다.

### L7 로드 밸런서의 특징

1. **컨텐츠 기반 라우팅:** URL, 쿠키, HTTP 헤더 등의 정보를 기반으로 트래픽을 특정 서버로 라우팅할 수 있습니다.
2. **세션 유지:** 클라이언트와 서버 간의 세션을 유지하여, 사용자가 동일한 서버와 상호작용하도록 할 수 있습니다.
3. **보안 기능:** SSL 종료, 방화벽, DDoS 방어 등의 보안 기능을 제공하여 서버를 보호합니다.
4. **정적 콘텐츠 캐싱:** 정적 콘텐츠를 캐싱하여 서버 부하를 줄이고, 응답 속도를 높일 수 있습니다.

## 커넥션 타임아웃과 리드 타임아웃에 대해 설명해주세요

### 커넥션 타임아웃 (Connection Timeout)

> **커넥션 타임아웃**은 클라이언트가 서버에 연결을 시도할 때, 서버가 일정 시간 내에 응답하지 않으면 연결을 포기하는 시간 한계를 의미합니다.  
> 주로 서버가 다운되었거나 네트워크가 불안정할 때 발생합니다.

### 리드 타임아웃 (Read Timeout)

> **리드 타임아웃**은 서버와의 연결이 성공적으로 이루어진 후, 서버로부터 데이터를 읽어들이는 동안 일정 시간 내에 응답이 없으면 연결을 종료하는 시간 한계를 의미합니다.  
> 주로 서버의 처리 속도가 느리거나 네트워크 지연이 발생할 때 설정됩니다.

### 두 타임아웃의 차이

- **커넥션 타임아웃**은 클라이언트가 서버에 연결할 때의 시간 제한을 의미하며, **리드 타임아웃**은 연결된 후 서버로부터 데이터를 읽어들이는 동안의 시간 제한을 의미합니다.
- 커넥션 타임아웃은 주로 서버에 연결할 수 있는지 여부를 판단하는 데 사용되고, 리드 타임아웃은 연결된 후 서버의 응답 속도를 조정하는 데 사용됩니다.

\*\* 혼자공부하는네트워크 - 강민철 저자님 도서를 참고하였습니다.
\*\*https://velog.io/@soopy368/web-Get%EA%B3%BC-Post%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90

```

```
